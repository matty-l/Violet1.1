package Compiler.Parser.Builder;

import Compiler.Parser.CFG.Termable;
import Compiler.Parser.Matcher.ChartRow;
import Compiler.Parser.Matcher.State;
import Compiler.Parser.ParserTree.ParserTreeNode;
import Compiler.Parser.Matcher.Chart;
import Compiler.Parser.ParserTree.ParserTreeNodeAbstraction;
import Neuralizer.IO.NeuralLog;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Stack;

/**
 * The original class ASTBuilder wsa built based on Earley's self-stated
 * parse-forest generating algorithm; as Tomita points out (74), this
 * is prone to failure, as seen in our implementation of it. We defer
 * to Grune, 210.
 * Created by Matt Levine on 4/30/14.
 */
public class ASTBuilderTomita implements Builder {

    private ParserTreeNode tree;

    /** Not implemented here **/
    public ArrayList<ParserTreeNode> build(State state){
        return null;
    }

    /** Builds the tree from an input state
     * @param chart a chat generated by a Matcher
     * @return an arraylist of head nodes; set of possible derivation trees
     */
    public ParserTreeNode build(Chart chart){
        ArrayList<State> states = new ArrayList<>();

        for (ChartRow row : chart){
            for (State st : row){
                if (st.completed()) {
                    states.add(st);
                }
            }
        }
        Collections.reverse(states);
        NeuralLog.logMessage(states.size()+" IS THE SIZE");

        tree = populateChildren(states);

        return tree;
    }

    /** Populates a state with its children in ParserTreeNode form
     * @param states the set of possibilities
     * @return associated ParserTreeNode
     */
    public ParserTreeNode populateChildren(ArrayList<State> states){
        //recursion is giving me SO MUCH SASS. Going explicit

        ParserTreeNodeAbstraction root = new ParserTreeNodeAbstraction(states.remove(0));
        Stack<ParserTreeNodeAbstraction> nodeStack = new Stack<>();
        nodeStack.add(root);

        //while we still haven't grabbed somebodies kids
        while (!nodeStack.isEmpty()){
            //pick him out to grab his kids
            ParserTreeNodeAbstraction node = nodeStack.pop();
            //for every term in his production
            for (Termable child_term : node.value.getProduction()){
                //loop over every state looking for somebody who matches his production
                for (int i = 0; i < states.size() ; i++) {
                    //the ith state avoid concurrency issues
                    State actual_child = states.get(i);
//                    NeuralLog.logMessage("Looking for "+child_term.getName() + " in "+actual_child.name);
                    //if this state matches in name the child_term
                    if (actual_child.name.equals(child_term.getName())) {
                        //remove the state from possibilities
                        states.remove(actual_child);
                        NeuralLog.logMessage(node + " is removing " + actual_child.name +
                                " at position " + node.value.getEnd_chartRow().getCFGToken().getLineNum() + " "
                                + node.value.getEnd_chartRow().getCFGToken().getColNum());
                        //make a new mutable parse tree node
                        ParserTreeNodeAbstraction child = new ParserTreeNodeAbstraction(actual_child);
                        //add him to his parent
                        node.addChild(child);
                        //mark the child to be populated, if it isn't a terminal
                        if (actual_child.getRules().size() > 0)
                            nodeStack.add(child);
                        break;
                    }
                    if (i == states.size() - 1)
                        throw new RuntimeException(
                                "TomitaBuilder Err: could not complete tree when " +
                                 node + " was looking for "+child_term.getName()+" ");
                }

            }
        }

        NeuralLog.logMessage("Has kids "+root.getNumChildren());
        return new ParserTreeNode(root.getChildren().get(0)/*Not Gamma*/);
    }

    /** Finds the state associated with\ the given termable and returns the population of
     * its children as a ParserTreeNode.
     * @param root the term
     * @param searchIndex the place to start
     * @param states the set of possibilities
     * @return associated parsetreenode
     */
    private State populateChildren(Termable root, int searchIndex,
                                            ArrayList<State> states){
        for (int i = searchIndex; i < states.size(); i++){
            if (states.get(i).name.equals(root.getName())){
                return states.get(i);
            }
        }
        return null; //must be terminal
    }

//    private Object[] walk(State nt, int end, ArrayList<ArrayList<State>> all){
//        Collections.reverse(all);
//        for (State st : all.get(end)){
//            System.out.println(nt.name + " is looking for "+nt.name);
//            if (st.name.equals(nt.name)){
//
//                ArrayList<State> stateSet = new ArrayList<State>(){{add(nt);}};
//                ChartRow prod = st.getEnd_chartRow();
//                prod.reverse();
//                System.out.println("then... "+prod.size());
//                for (State xstate : prod){
//                    System.out.println("Here? "+xstate.name);
//                    if (xstate.production.size() == 1) {
//                        end = (int) walk(xstate, end, all)[1];
//                        stateSet.add(1, xstate);
//                    }
//                    else{
//                        System.out.println("nonterminal");
//                        stateSet.add(1, st.getEnd_chartRow().get(0));
////                        System.out.println(st.getEnd_chartRow().get(0) + " was added");
//                        end--;
//                    }
//                }
//                return new Object[]{stateSet,end};
//            }
//        }
//        System.out.println("didn't find em");
//        return null;
//    }

    @Override
    public ParserTreeNode getTreeHead() {
        return tree;
    }

}
